#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
  Tool,
} from "@modelcontextprotocol/sdk/types.js";
import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs/promises";
import path from "path";
import { fileURLToPath } from "url";
import { glob } from "glob";

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const PROJECT_ROOT = process.env.HYPERSCAPE_PROJECT_ROOT || path.resolve(__dirname, "../../..");

class HyperscapeDevServer {
  private server: Server;

  constructor() {
    this.server = new Server(
      {
        name: "hyperscape-dev",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupHandlers();
  }

  private setupHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: this.getTools(),
      };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      return await this.handleToolCall(request.params.name, request.params.arguments || {});
    });
  }

  private getTools(): Tool[] {
    return [
      {
        name: "hyperscape_validate_types",
        description: "Validate TypeScript strong typing rules (no any/unknown types)",
        inputSchema: {
          type: "object",
          properties: {
            path: {
              type: "string",
              description: "Path to scan relative to project root (default: packages/plugin-hyperscape/src)",
            },
          },
        },
      },
      {
        name: "hyperscape_run_visual_test",
        description: "Execute visual test with colored cube proxies using Playwright",
        inputSchema: {
          type: "object",
          properties: {
            testName: {
              type: "string",
              description: "Name of the test file to run",
            },
          },
          required: ["testName"],
        },
      },
      {
        name: "hyperscape_generate_action",
        description: "Scaffold new ElizaOS action with proper types and test template",
        inputSchema: {
          type: "object",
          properties: {
            actionName: {
              type: "string",
              description: "Name of the action in camelCase (e.g., 'mineRock')",
            },
            description: {
              type: "string",
              description: "What the action does",
            },
            similes: {
              type: "array",
              items: { type: "string" },
              description: "Alternative names for the action",
            },
          },
          required: ["actionName", "description"],
        },
      },
      {
        name: "hyperscape_analyze_logs",
        description: "Parse and analyze error logs from /logs folder",
        inputSchema: {
          type: "object",
          properties: {
            logType: {
              type: "string",
              enum: ["error", "test", "runtime", "all"],
              description: "Type of logs to analyze (default: all)",
            },
            detailed: {
              type: "boolean",
              description: "Include detailed log contents (default: false)",
            },
          },
        },
      },
      {
        name: "hyperscape_get_world_state",
        description: "Query current Hyperscape world state from test instance",
        inputSchema: {
          type: "object",
          properties: {
            format: {
              type: "string",
              enum: ["summary", "detailed", "json"],
              description: "Output format (default: summary)",
            },
          },
        },
      },
      {
        name: "hyperscape_check_rpg_state",
        description: "Query RPG game state (inventory, skills, banks) from running instance",
        inputSchema: {
          type: "object",
          properties: {
            playerId: {
              type: "string",
              description: "Player ID to query (optional)",
            },
            component: {
              type: "string",
              enum: ["inventory", "skills", "bank", "all"],
              description: "Component to query (default: all)",
            },
          },
        },
      },
    ];
  }

  private async handleToolCall(name: string, args: Record<string, unknown>) {
    try {
      switch (name) {
        case "hyperscape_validate_types":
          return await this.validateTypes(args.path as string | undefined);

        case "hyperscape_run_visual_test":
          return await this.runVisualTest(args.testName as string);

        case "hyperscape_generate_action":
          return await this.generateAction(
            args.actionName as string,
            args.description as string,
            args.similes as string[] | undefined
          );

        case "hyperscape_analyze_logs":
          return await this.analyzeLogs(
            args.logType as string | undefined,
            args.detailed as boolean | undefined
          );

        case "hyperscape_get_world_state":
          return await this.getWorldState(args.format as string | undefined);

        case "hyperscape_check_rpg_state":
          return await this.checkRPGState(
            args.playerId as string | undefined,
            args.component as string | undefined
          );

        default:
          throw new Error(`Unknown tool: ${name}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        content: [
          {
            type: "text",
            text: `❌ Error: ${errorMessage}`,
          },
        ],
      };
    }
  }

  private async validateTypes(scanPath?: string) {
    const targetPath = scanPath || "packages/plugin-hyperscape/src";
    const fullPath = path.join(PROJECT_ROOT, targetPath);
    const violations: string[] = [];

    try {
      // Check for 'any' types
      const { stdout: anyResults } = await execAsync(
        `grep -rn ":\\s*any\\b" "${fullPath}" --include="*.ts" --exclude-dir=node_modules || true`,
        { cwd: PROJECT_ROOT }
      );

      if (anyResults.trim()) {
        violations.push("🚫 Found 'any' types:\n" + anyResults);
      }

      // Check for 'unknown' types
      const { stdout: unknownResults } = await execAsync(
        `grep -rn ":\\s*unknown\\b" "${fullPath}" --include="*.ts" --exclude-dir=node_modules || true`,
        { cwd: PROJECT_ROOT }
      );

      if (unknownResults.trim()) {
        violations.push("🚫 Found 'unknown' types:\n" + unknownResults);
      }

      // Check for 'as any' casts
      const { stdout: asAnyResults } = await execAsync(
        `grep -rn "as any" "${fullPath}" --include="*.ts" --exclude-dir=node_modules || true`,
        { cwd: PROJECT_ROOT }
      );

      if (asAnyResults.trim()) {
        violations.push("🚫 Found 'as any' casts:\n" + asAnyResults);
      }

      const resultText =
        violations.length > 0
          ? `❌ Type violations found:\n\n${violations.join("\n\n")}\n\n⚠️ Fix these violations according to strong typing rules in CLAUDE.md`
          : `✅ No type violations found in ${targetPath}\n\n✨ All files follow strong typing rules`;

      return {
        content: [
          {
            type: "text",
            text: resultText,
          },
        ],
      };
    } catch (error) {
      throw new Error(`Failed to validate types: ${error}`);
    }
  }

  private async runVisualTest(testName: string) {
    const testPath = path.join(PROJECT_ROOT, "packages/plugin-hyperscape");

    try {
      const { stdout, stderr } = await execAsync(
        `cd "${testPath}" && bun test ${testName}`,
        { cwd: testPath, timeout: 120000 }
      );

      const output = stdout + (stderr ? `\n\nStderr:\n${stderr}` : "");
      const passed = !output.includes("FAIL") && !output.includes("Error");

      return {
        content: [
          {
            type: "text",
            text: `${passed ? "✅" : "❌"} Visual test results for ${testName}:\n\n${output}`,
          },
        ],
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return {
        content: [
          {
            type: "text",
            text: `❌ Test failed:\n\n${errorMessage}`,
          },
        ],
      };
    }
  }

  private async generateAction(actionName: string, description: string, similes?: string[]) {
    const actionTemplate = `import type { Action, IAgentRuntime, Memory, State, HandlerCallback } from "@elizaos/core";
import { elizaLogger } from "@elizaos/core";
import type { HyperscapeService } from "../service";

export const ${actionName}Action: Action = {
    name: "${actionName.toUpperCase()}",
    similes: [${similes ? similes.map((s) => `"${s.toUpperCase()}"`).join(", ") : ""}],
    description: "${description}",
    validate: async (runtime: IAgentRuntime, message: Memory, state?: State) => {
        const service = runtime.getService<HyperscapeService>("hyperscape");
        if (!service) {
            elizaLogger.error("Hyperscape service not available");
            return false;
        }
        return true;
    },
    handler: async (
        runtime: IAgentRuntime,
        message: Memory,
        state: State | undefined,
        options: { [key: string]: unknown } = {},
        callback?: HandlerCallback
    ): Promise<boolean> => {
        const service = runtime.getService<HyperscapeService>("hyperscape");

        if (!service) {
            elizaLogger.error("Hyperscape service not available");
            return false;
        }

        elizaLogger.info(\`Executing ${actionName} action\`);

        try {
            // TODO: Implement action logic here
            // Access world state: service.getWorldState()
            // Access controls: service.getControls()
            // Send messages: callback({ text: "..." })

            return true;
        } catch (error) {
            elizaLogger.error(\`Error in ${actionName} action:\`, error);
            return false;
        }
    },
    examples: [
        [
            {
                user: "{{user1}}",
                content: { text: "Example user message that triggers this action" },
            },
            {
                user: "{{agentName}}",
                content: {
                    text: "Example agent response",
                    action: "${actionName.toUpperCase()}"
                },
            },
        ],
    ],
};
`;

    const testTemplate = `import { describe, it, expect, beforeAll } from "bun:test";
import { ${actionName}Action } from "../actions/${actionName}";

describe("${actionName}Action", () => {
    it("should validate successfully with hyperscape service", async () => {
        // TODO: Implement test with real Hyperscape world
        expect(true).toBe(true);
    });

    it("should execute ${actionName} action", async () => {
        // TODO: Implement test with visual verification
        expect(true).toBe(true);
    });
});
`;

    const actionPath = path.join(
      PROJECT_ROOT,
      "packages/plugin-hyperscape/src/actions",
      `${actionName}.ts`
    );

    const testPath = path.join(
      PROJECT_ROOT,
      "packages/plugin-hyperscape/src/__tests__/actions",
      `${actionName}.test.ts`
    );

    try {
      await fs.writeFile(actionPath, actionTemplate);
      await fs.writeFile(testPath, testTemplate);

      return {
        content: [
          {
            type: "text",
            text: `✅ Generated action files:\n\n📄 Action: ${actionPath}\n🧪 Test: ${testPath}\n\n⚠️ Next steps:\n1. Implement action logic in handler\n2. Add real tests with Hyperscape world\n3. Export action in src/index.ts\n4. Add to package.json agentConfig.actions`,
          },
        ],
      };
    } catch (error) {
      throw new Error(`Failed to generate action: ${error}`);
    }
  }

  private async analyzeLogs(logType: string = "all", detailed: boolean = false) {
    const logsDir = path.join(PROJECT_ROOT, "logs");

    try {
      const files = await fs.readdir(logsDir);
      const logContents = await Promise.all(
        files.map(async (file) => ({
          file,
          content: await fs.readFile(path.join(logsDir, file), "utf-8"),
          stats: await fs.stat(path.join(logsDir, file)),
        }))
      );

      const errors = {
        typeErrors: [] as { file: string; lines: string[] }[],
        runtimeErrors: [] as { file: string; lines: string[] }[],
        testFailures: [] as { file: string; lines: string[] }[],
        other: [] as { file: string; lines: string[] }[],
      };

      logContents.forEach(({ file, content }) => {
        const lines = content.split("\n");

        if (logType === "all" || logType === "error") {
          const typeErrorLines = lines.filter((l) => l.includes("TS") || l.includes("TypeError"));
          if (typeErrorLines.length > 0) {
            errors.typeErrors.push({ file, lines: typeErrorLines.slice(0, detailed ? 100 : 5) });
          }

          const runtimeErrorLines = lines.filter(
            (l) => l.includes("Error:") && !l.includes("TS")
          );
          if (runtimeErrorLines.length > 0) {
            errors.runtimeErrors.push({
              file,
              lines: runtimeErrorLines.slice(0, detailed ? 100 : 5),
            });
          }
        }

        if (logType === "all" || logType === "test") {
          const testFailureLines = lines.filter((l) => l.includes("FAIL") || l.includes("✗"));
          if (testFailureLines.length > 0) {
            errors.testFailures.push({ file, lines: testFailureLines.slice(0, detailed ? 100 : 5) });
          }
        }
      });

      let summary = `📊 Log Analysis (${files.length} files):\n\n`;
      summary += `🔴 Type Errors: ${errors.typeErrors.length} files\n`;
      summary += `⚠️  Runtime Errors: ${errors.runtimeErrors.length} files\n`;
      summary += `❌ Test Failures: ${errors.testFailures.length} files\n\n`;

      if (detailed) {
        if (errors.typeErrors.length > 0) {
          summary += `\n🔴 Type Errors:\n`;
          errors.typeErrors.forEach(({ file, lines }) => {
            summary += `\n📄 ${file}:\n${lines.join("\n")}\n`;
          });
        }

        if (errors.runtimeErrors.length > 0) {
          summary += `\n⚠️  Runtime Errors:\n`;
          errors.runtimeErrors.forEach(({ file, lines }) => {
            summary += `\n📄 ${file}:\n${lines.join("\n")}\n`;
          });
        }

        if (errors.testFailures.length > 0) {
          summary += `\n❌ Test Failures:\n`;
          errors.testFailures.forEach(({ file, lines }) => {
            summary += `\n📄 ${file}:\n${lines.join("\n")}\n`;
          });
        }
      }

      return {
        content: [
          {
            type: "text",
            text: summary || "✅ No logs found",
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `ℹ️  No logs directory found at ${logsDir}`,
          },
        ],
      };
    }
  }

  private async getWorldState(format: string = "summary") {
    // This would connect to a running Hyperscape instance
    // For now, return a placeholder
    return {
      content: [
        {
          type: "text",
          text: `🌍 World State Query:\n\nℹ️  This feature requires a running Hyperscape instance.\n\nTo use:\n1. Start Hyperscape world: cd packages/hyperscape && bun start\n2. Connect agent: bun run test:agents\n3. Query state again\n\nFormat: ${format}`,
        },
      ],
    };
  }

  private async checkRPGState(playerId?: string, component: string = "all") {
    // This would query the RPG game service
    // For now, return a placeholder
    return {
      content: [
        {
          type: "text",
          text: `🎮 RPG State Query:\n\nℹ️  This feature requires a running RPG instance.\n\nPlayer ID: ${playerId || "N/A"}\nComponent: ${component}\n\nTo use:\n1. Start RPG world\n2. Connect agent\n3. Query state again`,
        },
      ],
    };
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error("Hyperscape Development MCP server running on stdio");
  }
}

const server = new HyperscapeDevServer();
server.run().catch(console.error);
